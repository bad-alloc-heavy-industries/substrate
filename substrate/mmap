// SPDX-License-Identifier: BSD-3-Clause
#ifndef SUBSTRATE_MMAP
#define SUBSTRATE_MMAP

#include <cstdint>
#include <substrate/internal/defs>
#ifdef _WIN32
#	ifndef NOMINMAX
#		define NOMINMAX
#	endif
#	ifndef WIN32_LEAN_AND_MEAN
#		define WIN32_LEAN_AND_MEAN
#	endif
#	include <io.h>
#	include <windows.h>
#else
#	include <unistd.h>
#	include <sys/mman.h>
#endif
#include <stdexcept>
#include <cstring>
#include <cassert>
#include <string>
#if __cplusplus >= 201703L
#include <string_view>
#endif
#include <substrate/utility>

namespace substrate
{
#ifdef _WIN32
	static constexpr DWORD PROT_READ{PAGE_READONLY};
	static constexpr DWORD PROT_WRITE{PAGE_READWRITE};
	static constexpr int32_t MAP_PRIVATE{0};
	static constexpr int32_t MAP_FAILED{-1};
	static constexpr int32_t MAP_SHARED{0};

	static constexpr auto MADV_SEQUENTIAL{0};
	static constexpr auto MADV_WILLNEED{0};
	static constexpr auto MADV_DONTDUMP{0};
#endif

	struct mmap_t final
	{
	private:
		std::size_t _len{0};
#ifdef _WIN32
		HANDLE _mapping{INVALID_HANDLE_VALUE};
#endif
		void *_addr{nullptr};
		int32_t _fd{-1};

#ifdef _WIN32
		mmap_t(const mmap_t &map, const std::size_t len, const int32_t prot, const int32_t = 0,
		void * = nullptr) noexcept : _len{len}, _mapping{[&]() noexcept -> HANDLE
		{
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast,performance-no-int-to-ptr)
			auto *const file{reinterpret_cast<HANDLE>(_get_osfhandle(map._fd))};
			return CreateFileMappingA(file, nullptr, cleanProt(prot), DWORD(len >> 32U),
				DWORD(len), nullptr);
		}()}, _addr{[&]() noexcept -> void *
		{
			if (!_mapping)
				return nullptr;
			return MapViewOfFile(_mapping, protToAccess(prot), 0, 0, 0);
		}()} { }
#else
		mmap_t(const mmap_t &map, const std::size_t len, const int32_t prot, const int32_t flags = MAP_SHARED,
			void *addr = nullptr) noexcept : _len{len}, _addr{[&]() noexcept -> void *
			{
				const auto ptr = ::mmap(addr, len, prot, flags, map._fd, 0);
				return ptr == MAP_FAILED ? nullptr : ptr;
			}()}, _fd{-1} { }
#endif

		template<typename T> substrate::enable_if_t<substrate::is_pod<T>::value && !has_nullable_ctor<T>::value &&
			!std::is_same<T, void*>::value, T *> index(const std::size_t idx) const
		{
			if (idx < _len)
			{
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				const auto addr = reinterpret_cast<std::uintptr_t>(_addr); // lgtm[cpp/reinterpret-cast]
				// XXX: Do we actually want to be multiplying by sizeof(T) here?
				// Seems unlikely with the current index check
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				return new (reinterpret_cast<void *>(addr + (idx * sizeof(T)))) T{}; // lgtm[cpp/reinterpret-cast]
			}
			throw std::out_of_range("mmap_t index out of range");
		}

		template<typename T> substrate::enable_if_t<has_nullable_ctor<T>::value && !std::is_same<T, void*>::value, T *>
			index(const std::size_t idx) const
		{
			if (idx < _len)
			{
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				const auto addr = reinterpret_cast<std::uintptr_t>(_addr); // lgtm[cpp/reinterpret-cast]
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				return new (reinterpret_cast<void *>(addr + (idx * sizeof(T)))) T{nullptr}; // lgtm[cpp/reinterpret-cast]
			}
			throw std::out_of_range("mmap_t index out of range");
		}

		template<typename T> substrate::enable_if_t<std::is_same<T, void*>::value, void*>
			index(const std::size_t idx) const
		{
			if (idx < _len) {
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				const auto addr = reinterpret_cast<std::uintptr_t>(_addr); // lgtm[cpp/reinterpret-cast]
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				return reinterpret_cast<void *>(addr + idx); // lgtm[cpp/reinterpret-cast]
			}
			throw std::out_of_range("mmap_t index out of range");
		}

#ifdef _WIN32
		SUBSTRATE_CXX14_CONSTEXPR static DWORD cleanProt(const DWORD prot) noexcept
		{
			return (prot & PAGE_READWRITE) ? prot & ~PAGE_READONLY : prot;
		}

		SUBSTRATE_CXX14_CONSTEXPR static DWORD protToAccess(const DWORD prot) noexcept
		{
			if ((prot & PAGE_READWRITE) || (prot & PAGE_WRITECOPY))
				return FILE_MAP_WRITE;
			else if (prot & PAGE_READONLY)
				return FILE_MAP_READ;
			return {};
		}
#endif

	public:
		constexpr mmap_t() noexcept = default;
#ifndef _WIN32
		mmap_t(const int32_t fd, const std::size_t len, const int32_t prot, const int32_t flags = MAP_SHARED,
			void *addr = nullptr) noexcept : _len{len}, _addr{[&]() noexcept -> void *
			{
				const auto ptr = ::mmap(addr, len, prot, flags, fd, 0);
				return ptr == MAP_FAILED ? nullptr : ptr;
			}()}, _fd{fd} { }
		mmap_t(mmap_t &&map) noexcept : mmap_t{} { swap(map); }
		void operator =(mmap_t &&map) noexcept { swap(map); }

		~mmap_t() noexcept
		{
			if (_addr)
				::munmap(_addr, _len);
			if (_fd != -1)
				::close(_fd);
		}

		SUBSTRATE_NO_DISCARD(SUBSTRATE_CXX14_CONSTEXPR bool valid() const noexcept) { return _addr; }
#else
		mmap_t(const int32_t fd, const std::size_t len, const DWORD prot, const int32_t = 0,
			void * = nullptr) noexcept : _len{len}, _mapping{[&]() noexcept -> HANDLE
			{
				const auto file = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
				static_assert(sizeof(DWORD) == 4);
				return CreateFileMappingA(file, nullptr, cleanProt(prot), DWORD(len >> 32U),
					DWORD(len), nullptr);
			}()}, _addr{[&]() noexcept -> void *
			{
				if (!_mapping)
					return nullptr;
				return MapViewOfFile(_mapping, protToAccess(prot), 0, 0, 0);
			}()} { }

		mmap_t(const int32_t fd, const off_t offset, const std::size_t length, const DWORD prot,
			const int32_t = 0, void * = nullptr) noexcept : _len{length},
			_mapping{[&]() noexcept -> HANDLE
			{
				const auto file = reinterpret_cast<HANDLE>(_get_osfhandle(fd));
				static_assert(sizeof(DWORD) == 4);
#if 0
				return CreateFileMappingA(file, nullptr, cleanProt(prot), DWORD(length >> 32U),
					DWORD(length), nullptr);
#else
				return CreateFileMappingA(file, nullptr, cleanProt(prot), 0, 0, nullptr);
#endif
			}()}, _addr{[&]() noexcept -> void *
			{
				if (!_mapping)
					return nullptr;
#if 0
				return MapViewOfFile(_mapping, protToAccess(prot), DWORD(offset >> 32U), DWORD(offset), 0);
#else
				if (DWORD(length >> 32U))
					return nullptr;
				return MapViewOfFile(_mapping, protToAccess(prot), DWORD(offset >> 32U), DWORD(offset), SIZE_T(length));
#endif
			}()} { }

		~mmap_t() noexcept
		{
			if (_addr)
				UnmapViewOfFile(_addr);
			if (_mapping)
				CloseHandle(_mapping);
		}

		SUBSTRATE_NO_DISCARD(SUBSTRATE_CXX14_CONSTEXPR bool valid() const noexcept) { return _mapping && _addr; }
#endif
		mmap_t(const mmap_t &) = delete;
		mmap_t &operator =(const mmap_t &) = delete;

		void swap(mmap_t &map) noexcept
		{
			std::swap(_fd, map._fd);
			std::swap(_addr, map._addr);
#ifdef _WIN32
			std::swap(_mapping, map._mapping);
#endif
			std::swap(_len, map._len);
		}

		SUBSTRATE_NO_DISCARD(mmap_t dup(const int32_t prot, const std::size_t len, const int32_t flags,
			void *addr) const noexcept)
		{
			if (!valid())
				return {};
			return {*this, len, prot, flags, addr};
		}

		SUBSTRATE_NO_DISCARD(bool chperm(const int32_t prot) noexcept) { return mprotect(_addr, _len, prot) == 0; }

		template<typename T> T *address() noexcept { return static_cast<T *>(_addr); }
		template<typename T> const T *address() const noexcept { return static_cast<const T *>(_addr); }

		SUBSTRATE_NO_DISCARD(std::size_t length() const noexcept) { return _len; }

		template<typename T> T *operator [](const std::size_t idx) { return index<T>(idx); }
		template<typename T> const T *operator [](const off_t idx) const { return index<const T>(idx); }
		template<typename T> T *at(const std::size_t idx) { return index<T>(idx); }
		template<typename T> const T *at(const std::size_t idx) const { return index<const T>(idx); }

		void *address(const std::size_t offset) noexcept { return index<void *>(offset); }
		const void *address(const std::size_t offset) const noexcept { return index<const void *>(offset); }

		SUBSTRATE_NO_DISCARD(std::uintptr_t numeric_address() const noexcept)
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			{ return reinterpret_cast<std::uintptr_t>(_addr); } // lgtm[cpp/reinterpret-cast]

		SUBSTRATE_NO_DISCARD(bool lock() const noexcept)
			{ return lock(_len); }
		SUBSTRATE_NO_DISCARD(bool lock(const std::size_t length) const noexcept)
			{ return ::mlock(_addr, length) == 0; }
		SUBSTRATE_NO_DISCARD(bool lock_at(const std::size_t idx, const size_t length) const noexcept)
		{
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			const auto addr = reinterpret_cast<std::uintptr_t>(_addr); // lgtm[cpp/reinterpret-cast]
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			return ::mlock(reinterpret_cast<void *>(addr + idx), length) == 0; // lgtm[cpp/reinterpret-cast]
		}

		SUBSTRATE_NO_DISCARD(bool unlock() const noexcept)
			{ return unlock(_len); }
		SUBSTRATE_NO_DISCARD(bool unlock(const std::size_t length) const noexcept)
			{ return ::munlock(_addr, length) == 0; }
		SUBSTRATE_NO_DISCARD(bool unlock_at(const std::size_t idx, const std::size_t length) const noexcept)
		{
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			const auto addr = reinterpret_cast<std::uintptr_t>(_addr); // lgtm[cpp/reinterpret-cast]
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			return ::munlock(reinterpret_cast<void *>(addr + idx), length) == 0; // lgtm[cpp/reinterpret-cast]
		}

#ifndef __APPLE__
		SUBSTRATE_NO_DISCARD(bool remap(const int32_t flags, const std::size_t new_length) noexcept)
		{
			const auto old_len = _len;
			_len = new_length;

			return (_addr = ::mremap(_addr, old_len, _len, flags)) != MAP_FAILED;
		}

		SUBSTRATE_NO_DISCARD(bool remap(const int32_t flags, const std::size_t new_length,
			const std::uintptr_t new_addr) noexcept)
		{
			const auto old_len = _len;
			_len = new_length;

			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			const void *wanted_addr = reinterpret_cast<void *>(new_addr); // lgtm[cpp/reinterpret-cast]

			return (_addr = ::mremap(_addr, old_len, _len, flags, wanted_addr)) != MAP_FAILED;
		}
#endif

#ifndef _WIN32
		SUBSTRATE_NO_DISCARD(bool sync(const int flags = MS_SYNC | MS_INVALIDATE) const noexcept)
			{ return sync(_len, flags); }

		SUBSTRATE_NO_DISCARD(bool sync(const std::size_t length,
				const int flags = MS_SYNC | MS_INVALIDATE) const noexcept)
			{ return msync(_addr, length, flags) == 0; }

		SUBSTRATE_NO_DISCARD(bool advise(const int32_t advice) const noexcept)
			{ return advise(advice, _len); }
		SUBSTRATE_NO_DISCARD(bool advise(const int32_t advice, const std::size_t length) const noexcept)
			{ return ::madvise(_addr, length, advice) == 0; }
		SUBSTRATE_NO_DISCARD(bool advise_at(const int32_t advice, const std::size_t length,
			const std::size_t idx) const noexcept)
		{
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			const auto addr = reinterpret_cast<std::uintptr_t>(_addr); // lgtm[cpp/reinterpret-cast]
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			return ::madvise(reinterpret_cast<void *>(addr + idx), length, advice) == 0; // lgtm[cpp/reinterpret-cast]
		}
#else
		[[nodiscard]] bool sync() const noexcept { return sync(_len); }
		[[nodiscard]] bool sync(const std::size_t length) const noexcept
			{ return FlushViewOfFile(_addr, length); }

		[[nodiscard]] bool advise(const int32_t) const noexcept { return true; }
		[[nodiscard]] bool advise(const int32_t, const std::size_t) const noexcept { return true; }
		[[nodiscard]] bool advise_at(const int32_t, const std::size_t, const std::size_t) const noexcept
			{ return true; }
#endif

		template<typename T> void copyTo(const std::size_t idx, T &value) const
		{
			const auto src = index<const void *>(idx);
			assert(sizeof(T) <= _len - idx);
			std::memcpy(&value, src, sizeof(T));
		}

		template<typename T, std::size_t N> void copyTo(const std::size_t idx,
			std::array<T, N> &value) const
		{
			constexpr auto length{sizeof(T) * N};
			const auto src = index<const void *>(idx);
			assert(length <= _len - idx);
			std::memcpy(value.data(), src, length);
		}

		void copyTo(const std::size_t idx, std::string &value) const
		{
			const auto src = index<const void *>(idx);
			assert(value.size() <= _len - idx);
			std::memcpy(const_cast<char *>(value.data()), src, value.size());
		}

#if __cplusplus >= 201703L
		void copyTo(const std::size_t idx, std::string_view &value) const
		{
			const auto src = index<const void *>(idx);
			assert(value.size() <= _len - idx);
			std::memcpy(const_cast<char *>(value.data()), src, value.size());
		}
#endif

		template<typename T> void copyFrom(const std::size_t idx, const T &value) const
		{
			const auto dest = index<void *>(idx);
			assert(sizeof(T) <= _len - idx);
			std::memcpy(dest, &value, sizeof(T));
		}

		template<typename T, std::size_t N> void copyFrom(const std::size_t idx,
			const std::array<T, N> &value) const
		{
			constexpr auto length{sizeof(T) * N};
			const auto dest = index<void *>(idx);
			assert(length <= _len - idx);
			std::memcpy(dest, value.data(), length);
		}

		void copyFrom(const std::size_t idx, const std::string &value) const
		{
			const auto dest = index<void *>(idx);
			assert(value.size() <= _len - idx);
			std::memcpy(dest, value.data(), value.size());
		}

#if __cplusplus >= 201703L
		void copyFrom(const std::size_t idx, const std::string_view &value) const
		{
			const auto dest = index<void *>(idx);
			assert(value.size() <= _len - idx);
			std::memcpy(dest, value.data(), value.size());
		}
#endif

		bool operator ==(const mmap_t &b) const noexcept
			{ return _fd == b._fd && _addr == b._addr && _len == b._len; }
		bool operator !=(const mmap_t &b) const noexcept { return !(*this == b); }
	};

	inline void swap(mmap_t &a, mmap_t &b) noexcept { a.swap(b); }
}


#endif /* SUBSTRATE_MMAP */
/* vim: set ft=cpp ts=4 sw=4 noexpandtab: */
